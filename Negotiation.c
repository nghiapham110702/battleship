/* 
 * File:   Negotiation.c
 * Author: Nghia Pham
 */
#include "Negotiation.h"
#include <stdint.h>
#include <stdlib.h>
#include "BOARD.h"

/**
 *  The outcome of the negotiation is a coin flip, and can be either HEADS or TAILS:
 */


/**
 *  All negotiation data occurs on uniformly-sized data packets.
 */


/**
 * The commitment packet is generated using a hash that utilizes a public key, which is defined here:
 */


/**
 * This function implements a one-way hash.  It maps its input, A, 
 * into an image, #a, in a way that is hard to reverse, but easy 
 * to reproduce.
 * @param secret        //A number that a challenger commits to
 * @return hash         //the hashed value of the secret commitment.
 *
 * This function implements the "Beef Hash," a variant of a Rabin hash.
 * The result is ((the square of the input) modulo the constant key 0xBEEF).
 * So, for example, 
 * 
 * NegotiationHash(3) == 9
 * NegotiationHash(12345) == 43182
 */
NegotiationData NegotiationHash(NegotiationData secret){
    uint64_t Result;
    NegotiationData Hash;
    Result = ((uint64_t)secret * (uint64_t)secret) % PUBLIC_KEY;
    Hash = Result;
    return Hash;
    
    
}

/**
 * Detect cheating.  An accepting agent will receive both a commitment hash
 * and a secret number from the challenging agent.  This function
 * verifies that the secret and the commitment hash agree, hopefully
 * detecting cheating by the challenging agent.
 *
 * @param secret        //the previously secret number that the challenging agent has revealed
 * @param commitment    //the hash of the secret number
 * @return TRUE if the commitment validates the revealed secret, FALSE otherwise
 */
int NegotiationVerify(NegotiationData secret, NegotiationData commitment){
    if (commitment == NegotiationHash(secret)){
        return 1;
    }else{
        return 0;
    }
}

/**
 * The coin-flip protocol uses random numbers generated by both
 * agents to determine the outcome of the coin flip.
 *
 * The parity of a bitstring is 1 if there are an odd number of one bits,
 *   and 0 otherwise.
 * So, for example, the number 0b01101011 has 5 ones.  If the parity of
 * A XOR B is 1, then the outcome is HEADS.  Otherwise, the outcome is TAILS.
 */
NegotiationOutcome NegotiateCoinFlip(NegotiationData A, NegotiationData B){
    NegotiationData Result = A ^ B; // xor A and B
    int i;
    int Tracker = 0;
    int x = 1;
    for (i = 0; i < 32; i++){
        if(Result & (x << i)){
            Tracker = Tracker + 1;
        }
    }
    if ((Tracker % 2) == 1){
        return HEADS;
    }else{
        return TAILS;
    }
}



